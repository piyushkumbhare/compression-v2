When constructing a Huffman tree, if you encounter two nodes (a leaf and an internal node) with equal frequencies, a common heuristic is to give preference to the internal node and consider it "less" than the leaf node. This is not strictly required by the algorithm but is a convention that helps maintain a deterministic tree structure, which can simplify decoding.
Why prefer internal nodes?

    Consistency: If you consistently treat internal nodes as "less," your Huffman tree will always be constructed in a deterministic way, ensuring that encoding is consistent across different implementations.
    Stability: By treating internal nodes as lower in priority, you ensure that the tree structure remains balanced and stable in cases of ties. This can slightly optimize the decoding process.
    Non-leaf propagation: Internal nodes are just structural—they don’t contribute direct data, so putting them "higher" in the tree ensures leaf nodes (actual data-carrying nodes) are lower in the tree, which is often desirable for compression efficiency.

How to implement this?

In your priority queue or sorting mechanism for Huffman tree construction, when two nodes have equal frequencies, you can break ties by prioritizing internal nodes over leaf nodes. Here's how you might express this comparison:

    If the frequency of the two nodes is different, compare by frequency.
    If the frequency is the same:
        Consider an internal node "less" than a leaf node.

In Rust, assuming you're using something like a binary heap or priority queue to construct the tree, you can implement this using custom comparison logic.
Example Comparison in Rust: